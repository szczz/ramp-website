"use strict";(self["webpackChunkramp_website"]=self["webpackChunkramp_website"]||[]).push([[1965],{1965:function(n,t,e){e.r(t),e.d(t,{buffer:function(){return z},changeDefaultSpatialReferenceTolerance:function(){return Y},clearDefaultSpatialReferenceTolerance:function(){return Z},clip:function(){return w},contains:function(){return m},convexHull:function(){return N},crosses:function(){return g},cut:function(){return d},densify:function(){return W},difference:function(){return k},disjoint:function(){return A},distance:function(){return h},equals:function(){return S},extendedSpatialReferenceInfo:function(){return y},flipHorizontal:function(){return B},flipVertical:function(){return G},generalize:function(){return _},geodesicArea:function(){return Q},geodesicBuffer:function(){return C},geodesicDensify:function(){return F},geodesicLength:function(){return U},intersect:function(){return T},intersectLinesToPoints:function(){return X},intersects:function(){return R},isSimple:function(){return D},nearestCoordinate:function(){return H},nearestVertex:function(){return I},nearestVertices:function(){return P},offset:function(){return E},overlaps:function(){return O},planarArea:function(){return K},planarLength:function(){return M},relate:function(){return v},rotate:function(){return q},simplify:function(){return J},symmetricDifference:function(){return L},touches:function(){return b},union:function(){return V},within:function(){return x}});var r=e(98503),i=e(35271);function u(n){return Array.isArray(n)?n[0]?.spatialReference:n?.spatialReference}function c(n){return n&&(Array.isArray(n)?n.map(c):n.toJSON?n.toJSON():n)}function a(n){return Array.isArray(n)?n.map((n=>(0,r.b3)(n))):(0,r.b3)(n)}function o(n,t){let e;return Array.isArray(n)?e=n:(e=[],e.push(n),null!=t&&e.push(t)),e}let f;async function s(){return f||(f=(0,i.p)("geometryEngineWorker",{strategy:"distributed"})),f}async function l(n,t){return(await s()).invoke("executeGEOperation",{operation:n,parameters:c(t)})}async function p(n,t){const e=await s();return Promise.all(e.broadcast("executeGEOperation",{operation:n,parameters:c(t)}))}function y(n){return l("extendedSpatialReferenceInfo",[n])}async function w(n,t){return a(await l("clip",[u(n),n,t]))}async function d(n,t){return a(await l("cut",[u(n),n,t]))}function m(n,t){return l("contains",[u(n),n,t])}function g(n,t){return l("crosses",[u(n),n,t])}function h(n,t,e){return l("distance",[u(n),n,t,e])}function S(n,t){return l("equals",[u(n),n,t])}function R(n,t){return l("intersects",[u(n),n,t])}function b(n,t){return l("touches",[u(n),n,t])}function x(n,t){return l("within",[u(n),n,t])}function A(n,t){return l("disjoint",[u(n),n,t])}function O(n,t){return l("overlaps",[u(n),n,t])}function v(n,t,e){return l("relate",[u(n),n,t,e])}function D(n){return l("isSimple",[u(n),n])}async function J(n){return a(await l("simplify",[u(n),n]))}async function N(n,t=!1){return a(await l("convexHull",[u(n),n,t]))}async function k(n,t){return a(await l("difference",[u(n),n,t]))}async function L(n,t){return a(await l("symmetricDifference",[u(n),n,t]))}async function T(n,t){return a(await l("intersect",[u(n),n,t]))}async function V(n,t=null){const e=o(n,t);return a(await l("union",[u(e),e]))}async function E(n,t,e,r,i,c){return a(await l("offset",[u(n),n,t,e,r,i,c]))}async function z(n,t,e,r=!1){const i=[u(n),n,t,e,r];return a(await l("buffer",i))}async function C(n,t,e,r,i,c){const o=[u(n),n,t,e,r,i,c];return a(await l("geodesicBuffer",o))}async function H(n,t,e=!0){const i=await l("nearestCoordinate",[u(n),n,t,e]);return{...i,coordinate:r.bv.fromJSON(i.coordinate)}}async function I(n,t){const e=await l("nearestVertex",[u(n),n,t]);return{...e,coordinate:r.bv.fromJSON(e.coordinate)}}async function P(n,t,e,i){return(await l("nearestVertices",[u(n),n,t,e,i])).map((n=>({...n,coordinate:r.bv.fromJSON(n.coordinate)})))}function j(n){return"xmin"in n?n.center:"x"in n?n:n.extent?.center}async function q(n,t,e){if(null==n)throw new $;const r=n.spatialReference;if(null==(e=e??j(n)))throw new $;const i=n.constructor.fromJSON(await l("rotate",[r,n,t,e]));return i.spatialReference=r,i}async function B(n,t){if(null==n)throw new $;const e=n.spatialReference;if(null==(t=t??j(n)))throw new $;const r=n.constructor.fromJSON(await l("flipHorizontal",[e,n,t]));return r.spatialReference=e,r}async function G(n,t){if(null==n)throw new $;const e=n.spatialReference;if(null==(t=t??j(n)))throw new $;const r=n.constructor.fromJSON(await l("flipVertical",[e,n,t]));return r.spatialReference=e,r}async function _(n,t,e,r){return a(await l("generalize",[u(n),n,t,e,r]))}async function W(n,t,e){return a(await l("densify",[u(n),n,t,e]))}async function F(n,t,e,r=0){return a(await l("geodesicDensify",[u(n),n,t,e,r]))}function K(n,t){return l("planarArea",[u(n),n,t])}function M(n,t){return l("planarLength",[u(n),n,t])}function Q(n,t,e){return l("geodesicArea",[u(n),n,t,e])}function U(n,t,e){return l("geodesicLength",[u(n),n,t,e])}async function X(n,t){return a(await l("intersectLinesToPoints",[u(n),n,t]))}async function Y(n,t){await p("changeDefaultSpatialReferenceTolerance",[n,t])}async function Z(n){await p("clearDefaultSpatialReferenceTolerance",[n])}class $ extends Error{constructor(){super("Illegal Argument Exception")}}}}]);
//# sourceMappingURL=1965.e00a6cd5.js.map