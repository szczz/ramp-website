"use strict";(self["webpackChunkramp_website"]=self["webpackChunkramp_website"]||[]).push([[2611],{97920:function(e,t,i){i.d(t,{d:function(){return l}});var s=i(98503);const n=new s.ax({esriClassifyEqualInterval:"equal-interval",esriClassifyManual:"manual",esriClassifyNaturalBreaks:"natural-breaks",esriClassifyQuantile:"quantile",esriClassifyStandardDeviation:"standard-deviation",esriClassifyDefinedInterval:"defined-interval"}),a=new s.ax({esriNormalizeByLog:"log",esriNormalizeByPercentOfTotal:"percent-of-total",esriNormalizeByField:"field"});let r=class extends s.v{constructor(e){super(e),this.type="class-breaks-definition",this.breakCount=null,this.classificationField=null,this.classificationMethod=null,this.normalizationField=null,this.normalizationType=null}set standardDeviationInterval(e){"standard-deviation"===this.classificationMethod&&this._set("standardDeviationInterval",e)}set definedInterval(e){"defined-interval"===this.classificationMethod&&this._set("definedInterval",e)}};(0,s.k)([(0,s.bk)({classBreaksDef:"class-breaks-definition"})],r.prototype,"type",void 0),(0,s.k)([(0,s.o)({json:{write:!0}})],r.prototype,"breakCount",void 0),(0,s.k)([(0,s.o)({json:{write:!0}})],r.prototype,"classificationField",void 0),(0,s.k)([(0,s.o)({type:String,json:{read:n.read,write:n.write}})],r.prototype,"classificationMethod",void 0),(0,s.k)([(0,s.o)({json:{write:!0}})],r.prototype,"normalizationField",void 0),(0,s.k)([(0,s.o)({json:{read:a.read,write:a.write}})],r.prototype,"normalizationType",void 0),(0,s.k)([(0,s.o)({value:null,json:{write:!0}})],r.prototype,"standardDeviationInterval",null),(0,s.k)([(0,s.o)({value:null,json:{write:!0}})],r.prototype,"definedInterval",null),r=(0,s.k)([(0,s.A)("esri.rest.support.ClassBreaksDefinition")],r);const l=r},92611:function(e,t,i){i.d(t,{V:function(){return ee}});var s=i(98503),n=i(49555),a=i(58469),r=i(45121),l=i(81519),o=i(17113),u=i(22555),c=i(55532),h=i(42335),d=i(94706),f=i(8891),m=i(75412),p=i(55605),y=i(36879),g=i(76005);let x=class{constructor(e,t){this._cache=new l.e(e),this._invalidCache=new l.e(t)}get(e,t){const i=`${t.uid}:${e}`,s=this._cache.get(i);if(s)return s;if(null!=this._invalidCache.get(i))return null;try{const s=o.Z.create(e,{fieldsIndex:t});return this._cache.put(i,s),s}catch(n){return this._invalidCache.put(i,n),null}}getError(e,t){const i=`${t.uid}:${e}`;return this._invalidCache.get(i)??null}};const F=new x(50,500),_="unsupported-query",w=" as ",b=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeBigInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong"]),v=new Set(["esriFieldTypeDate","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]),I=new Set(["esriFieldTypeString","esriFieldTypeGUID","esriFieldTypeGlobalID",...b,...v]);function S(e,t,i={}){const n=R(t,e);if(!n){const i=F.getError(t,e);throw new s.s(_,"invalid SQL expression",{expression:t,error:i})}const a=i.expressionName||"expression";if(i.validateStandardized&&!n.isStandardized)throw new s.s(_,`${a} is not standard`,{expression:t});if(i.validateAggregate&&!n.isAggregate)throw new s.s(_,`${a} does not contain a valid aggregate function`,{expression:t});return n.fieldNames}function T(e,t,i,s){if(!i)return!0;const n="where clause";return z(e,t,S(e,i,{validateStandardized:!0,expressionName:n}),{expressionName:n,query:s}),!0}function V(e,t,i,n,a){if(!i)return!0;const r="having clause",l=S(e,i,{validateAggregate:!0,expressionName:r});if(z(e,t,l,{expressionName:r,query:a}),!R(i,e)?.getExpressions().every((t=>{const{aggregateType:i,field:s}=t,a=e.get(s)?.name;return n.some((t=>{const{onStatisticField:s,statisticType:n}=t;return e.get(s)?.name===a&&n.toLowerCase().trim()===i}))})))throw new s.s(_,"expressions in having clause should also exist in outStatistics",{having:i});return!0}function R(e,t){return e?F.get(e,t):null}function M(e){return/\((.*?)\)/.test(e)?e:e.split(w)[0]}function A(e){return e.split(w)[1]}function z(e,t,i,n={}){const a=new Map;if(C(a,e,t,n.allowedFieldTypes??I,i),a.size){const e=n.expressionName??"expression";throw new s.s(_,`${e} contains invalid or missing fields`,{errors:Array.from(a.values()),query:n.query})}}function C(e,t,i,s,n){const a=n.includes("*")?[...i,...n.filter((e=>"*"!==e))]:n;for(const l of a)if(t.get(l))D(e,t,i,s,l);else try{const n=S(t,M(l),{validateStandardized:!0});for(const a of n)D(e,t,i,s,a)}catch(r){e.set(l,{type:"expression-error",expression:l,error:r})}}function D(e,t,i,s,n){const a=t.get(n);a?i.has(a.name)?"all"!==s&&!1===s?.has(a.type)&&e.set(n,{type:"invalid-type",fieldName:a.name,fieldType:u.i.fromJSON(a.type),allowedFieldTypes:Array.from(s,(e=>u.i.fromJSON(e)))}):e.set(n,{type:"missing-field",fieldName:a.name}):e.set(n,{type:"invalid-field",fieldName:n})}const E=5;let N=class{constructor(){this._storage=new Map,this._purgeInterval=E,this._sweep=()=>{if(this._timer=void 0,!this._storage)return;const e=1e3*this._purgeInterval,t=performance.now()-e;for(const[i,s]of this._storage){if(!(s.time<t))return void(this._storage.size>0&&(this._timer=setTimeout(this._sweep,e)));this._storage.delete(i)}}}destroy(){this._storage?.clear(),this._storage=null,clearTimeout(this._timer)}get size(){return this._storage?.size??0}put(e,t){this._storage?.set(e,new P(t)),this._scheduleSweep()}get(e){if(!this._storage)return;const t=this._storage?.get(e);return t?(this._storage?.delete(e),t.time=performance.now(),this._storage?.set(e,t),t.items):void 0}clear(){this._storage?.clear()}_scheduleSweep(){this._storage&&(this._timer??=setTimeout(this._sweep,1e3*this._purgeInterval))}},q=0;class P{constructor(e){this.items=e,this.time=performance.now(),this.id=q++}}let Q=class{constructor(e,t,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues??!1,this.fieldsIndex=i,this.featureAdapter=t;const s=e.outFields;if(s&&!s.includes("*")){this.outFields=s;let e=0;for(const t of s){const s=M(t),n=this.fieldsIndex.get(s),a=n?null:R(s,i),r=n?n.name:A(t)||"FIELD_EXP_"+e++;this._fieldDataCache.set(t,{alias:r,clause:a})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach((e=>this.getAttributes(e))),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,i){const s=i?i.name:t;let n=null;return this._fieldDataCache.has(s)?n=this._fieldDataCache.get(s)?.clause:i||(n=R(t,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:n})),i?this.featureAdapter.getAttribute(e,s):n?.calculateValue(e,this.featureAdapter)}getDataValues(e,t,i=!0){const n=t.normalizationType,a=t.normalizationTotal,r=this.fieldsIndex.get(t.field),l=(0,s.bH)(r)||(0,s.bI)(r),o=(0,s.ap)(r);return e.map((e=>{let s=t.field&&this.getFieldValue(e,t.field,this.fieldsIndex.get(t.field));if(t.field2?(s=`${(0,p.m)(s)}${t.fieldDelimiter}${(0,p.m)(this.getFieldValue(e,t.field2,this.fieldsIndex.get(t.field2)))}`,t.field3&&(s=`${s}${t.fieldDelimiter}${(0,p.m)(this.getFieldValue(e,t.field3,this.fieldsIndex.get(t.field3)))}`)):"string"==typeof s&&i&&(l?s=s?new Date(s).getTime():null:o&&(s=s?(0,m.I)(s):null)),n&&Number.isFinite(s)){const i="field"===n&&t.normalizationField?this.getFieldValue(e,t.normalizationField,this.fieldsIndex.get(t.normalizationField)):null;s=(0,p.B)(s,n,i,a)}return s}))}async getExpressionValues(e,t,i,n,a){const{arcadeUtils:r}=await(0,s.bG)(),l=r.hasGeometryOperations(t);l&&await r.enableGeometryOperations();const o=r.createFunction(t),u=r.getViewInfo(i),h={fields:this.fieldsIndex.fields};return e.map((e=>{const t={attributes:this.featureAdapter.getAttributes(e),layer:h,geometry:l?{...(0,c.a)(n.geometryType,n.hasZ,n.hasM,this.featureAdapter.getGeometry(e)),spatialReference:i?.spatialReference}:null},s=r.createExecContext(t,u,a);return r.executeFunction(o,s)}))}validateItem(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:R(t,this.fieldsIndex)}),this._fieldDataCache.get(t)?.clause?.testFeature(e,this.featureAdapter)??!1}validateItems(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:R(t,this.fieldsIndex)}),this._fieldDataCache.get(t)?.clause?.testSet(e,this.featureAdapter)??!1}_processAttributesForOutFields(e){const t=this.outFields;if(!t?.length)return this.featureAdapter.getAttributes(e);const i={};for(const s of t){const{alias:t,clause:n}=this._fieldDataCache.get(s);i[t]=n?n.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,t)}return i}_processAttributesForDistinctValues(e){if(null==e||!this.returnDistinctValues)return e;const t=this.outFields,i=[];if(t)for(const a of t){const{alias:t}=this._fieldDataCache.get(a);i.push(e[t])}else for(const a in e)i.push(e[a]);const s=`${(t||["*"]).join(",")}=${i.join(",")}`;let n=this._returnDistinctMap.get(s)||0;return this._returnDistinctMap.set(s,++n),n>1?null:e}};function G(e,t,i){return{objectId:e,target:t,distance:i,type:"vertex"}}function O(e,t,i,s,n,a=!1){return{objectId:e,target:t,distance:i,type:"edge",start:s,end:n,draped:a}}class k{constructor(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new Q(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query;if(!t?.length)return 1;const n=new Map,a=new Map,r=new Set;for(const l of s){const{statisticType:s}=l,o="exceedslimit"!==s?l.onStatisticField:void 0;if(!a.has(o)){const i=[];for(const s of t){const t=this._getAttributeValues(e,s,n);i.push(t)}a.set(o,this._calculateUniqueValues(i,e.returnDistinctValues))}const u=a.get(o);for(const t in u){const{data:s,items:n}=u[t],a=s.join(",");i&&!e.validateItems(n,i)||r.add(a)}}return r.size}async createQueryResponse(){let e;if(e=this.query.outStatistics?this.query.outStatistics.some((e=>"exceedslimit"===e.statisticType))?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const t=this.query.geometry;(0,s.cg)(this.query.outSR)&&!(0,s.bh)(t.spatialReference,this.query.outSR)?e.queryGeometry=(0,c.h)({spatialReference:this.query.outSR,...(0,h.j)(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=(0,c.h)({spatialReference:this.query.outSR,...t})}return e}createSnappingResponse(e,t){const i=this.featureAdapter,s=Z(this.hasZ,this.hasM),{point:n,mode:a}=e,r="number"==typeof e.distance?e.distance:e.distance.x,l="number"==typeof e.distance?e.distance:e.distance.y,o={candidates:[]},u="esriGeometryPolygon"===this.geometryType,c=this._getPointCreator(a,this.spatialReference,t),h=new B(null,0),d=new B(null,0),f={x:0,y:0,z:0};for(const m of this.items){const t=i.getGeometry(m);if(null==t)continue;const{coords:a,lengths:p}=t;if(h.coords=a,d.coords=a,e.returnEdge){let e=0;for(let t=0;t<p.length;t++){const a=p[t];for(let t=0;t<a;t++,e+=s){const u=h;if(u.coordsIndex=e,t!==a-1){const t=d;t.coordsIndex=e+s;const a=f;j(f,n,u,t);const h=(n.x-a.x)/r,p=(n.y-a.y)/l,y=h*h+p*p;y<=1&&o.candidates.push(O(i.getObjectId(m),c(a),Math.sqrt(y),c(u),c(t)))}}}}if("none"!==e.vertexMode){const t=u?a.length-s:a.length;if("all"===e.vertexMode)for(let e=0;e<t;e+=s){const t=h;t.coordsIndex=e;const s=(n.x-t.x)/r,a=(n.y-t.y)/l,u=s*s+a*a;u<=1&&o.candidates.push(G(i.getObjectId(m),c(t),Math.sqrt(u)))}else if("ends"===e.vertexMode){const e=[0];u||e.push(a.length-s);for(const t of e){const e=h;e.coordsIndex=t;const s=(n.x-e.x)/r,a=(n.y-e.y)/l,u=s*s+a*a;u<=1&&o.candidates.push(G(i.getObjectId(m),c(e),Math.sqrt(u)))}}}}return o.candidates.sort(((e,t)=>e.distance-t.distance)),o}_getPointCreator(e,t,i){const n=null==i||(0,s.bh)(t,i)?e=>e:e=>(0,h.j)(e,t,i),{hasZ:a}=this,r=0;return"3d"===e?a?({x:e,y:t,z:i})=>n({x:e,y:t,z:i}):({x:e,y:t})=>n({x:e,y:t,z:r}):({x:e,y:t})=>n({x:e,y:t})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:i,normalizationField:n,normalizationType:a,normalizationTotal:r,minValue:l,maxValue:o,scale:u,timeZone:c,outStatisticTypes:h}=e,d=this.fieldsIndex.get(t),f=(0,s.ag)(d)||(0,s.bH)(d)||(0,s.bI)(d),m=await this._getDataValues({field:t,valueExpression:i,normalizationField:n,normalizationType:a,normalizationTotal:r,scale:u,timeZone:c}),y=(0,p.d)({normalizationType:a,normalizationField:n,minValue:l,maxValue:o}),g={value:.5,fieldType:d?.type},x=(0,s.ce)(d)?(0,p.f)({values:m,supportsNullCount:y,percentileParams:g,outStatisticTypes:h}):(0,p.p)({values:m,minValue:l,maxValue:o,useSampleStdDev:!a,supportsNullCount:y,percentileParams:g,outStatisticTypes:h});return(0,p.C)(x,h,f)}async createUniqueValuesResponse(e){const{field:t,valueExpression:i,domains:s,returnAllCodedValues:n,scale:a,timeZone:r}=e,l=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:i,scale:a,timeZone:r},!1),o=(0,p.k)(l);return(0,p.$)(o,s,n,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:l,minValue:o,maxValue:u,numClasses:c,scale:h,timeZone:d}=e,f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,scale:h,timeZone:d}),m=(0,p.E)(f,{field:t,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:l,minValue:o,maxValue:u,numClasses:c});return(0,p.P)(m,r)}async createHistogramResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:l,minValue:o,maxValue:u,numBins:c,scale:h,timeZone:d}=e,f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,scale:h,timeZone:d});return(0,p.U)(f,{field:t,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:l,minValue:o,maxValue:u,numBins:c})}_sortFeatures(e,t,i){if(e.length>1&&t?.length)for(const s of t.reverse()){const t=s.split(" "),n=t[0],a=this.fieldsIndex.get(n),r=!!t[1]&&"desc"===t[1].toLowerCase(),l=(0,p.g)(a?.type,r);e.sort(((e,t)=>{const s=i(e,n,a),r=i(t,n,a);return l(s,r)}))}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:i,hasM:s,hasZ:n,objectIdField:a,spatialReference:r}=this,{outFields:l,outSR:o,quantizationParameters:u,resultRecordCount:h,resultOffset:d,returnZ:m,returnM:p}=e,y=null!=h&&t.length>(d||0)+h,g=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map((e=>this.fieldsIndex.get(e))));return{exceededTransferLimit:y,features:this._createFeatures(e,t),fields:g,geometryType:i,hasM:s&&p,hasZ:n&&m,objectIdFieldName:a,spatialReference:(0,c.h)(o||r),transform:u&&(0,f.s)(u)||null}}_createFeatures(e,t){const i=new Q(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:n}=this,{orderByFields:a,quantizationParameters:r,returnGeometry:l,returnCentroid:o,maxAllowableOffset:u,resultOffset:h,resultRecordCount:d,returnZ:m=!1,returnM:p=!1}=e,y=n&&m,g=s&&p;let x=[],F=0;const _=[...t];if(this._sortFeatures(_,a,((e,t,s)=>i.getFieldValue(e,t,s))),this.geometryType&&(l||o)){const e=(0,f.s)(r)??void 0,t="esriGeometryPolygon"===this.geometryType||"esriGeometryPolyline"===this.geometryType;if(l&&!o)for(const s of _){const n=this.featureAdapter.getGeometry(s),a={attributes:i.getAttributes(s),geometry:(0,c.a)(this.geometryType,this.hasZ,this.hasM,n,u,e,y,g)};t&&n&&!a.geometry&&(a.centroid=(0,c.y)(this,this.featureAdapter.getCentroid(s,this),e)),x[F++]=a}else if(!l&&o)for(const s of _)x[F++]={attributes:i.getAttributes(s),centroid:(0,c.y)(this,this.featureAdapter.getCentroid(s,this),e)};else for(const s of _)x[F++]={attributes:i.getAttributes(s),centroid:(0,c.y)(this,this.featureAdapter.getCentroid(s,this),e),geometry:(0,c.a)(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(s),u,e,y,g)}}else for(const c of _){const e=i.getAttributes(c);e&&(x[F++]={attributes:e})}const w=h||0;if(null!=d){const e=w+d;x=x.slice(w,Math.min(x.length,e))}return x}_createExceedsLimitQueryResponse(e){let t=!1,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,n=Number.POSITIVE_INFINITY;for(const a of e.outStatistics??[])if("exceedslimit"===a.statisticType){i=null!=a.maxPointCount?a.maxPointCount:Number.POSITIVE_INFINITY,s=null!=a.maxRecordCount?a.maxRecordCount:Number.POSITIVE_INFINITY,n=null!=a.maxVertexCount?a.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)t=this.items.length>i;else if(this.items.length>s)t=!0;else{const e=Z(this.hasZ,this.hasM),i=this.featureAdapter;t=this.items.reduce(((e,t)=>{const s=i.getGeometry(t);return e+(null!=s&&s.coords.length||0)}),0)/e>n}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},i=[],n=new Map,a=new Map,r=new Map,l=new Map,o=new Q(e,this.featureAdapter,this.fieldsIndex),u=e.outStatistics,{groupByFieldsForStatistics:c,having:h,orderByFields:d,resultRecordCount:f}=e,m=c?.length,p=!!m,y=p?c[0]:null,g=p&&!this.fieldsIndex.get(y);for(const F of u??[]){const{outStatisticFieldName:e,statisticType:u}=F,d=F,f="exceedslimit"!==u?F.onStatisticField:void 0,x="percentile_disc"===u||"percentile_cont"===u,_="EnvelopeAggregate"===u||"CentroidAggregate"===u||"ConvexHullAggregate"===u,w=p&&1===m&&(f===y||g)&&"count"===u;if(p){if(!r.has(f)){const e=[];for(const t of c){const i=this._getAttributeValues(o,t,n);e.push(i)}r.set(f,this._calculateUniqueValues(e,!_&&o.returnDistinctValues))}const t=r.get(f);if(!t)continue;const i=Object.keys(t);for(const s of i){const{count:i,data:a,items:r,itemPositions:u}=t[s],m=a.join(",");if(!h||o.validateItems(r,h)){const t=l.get(m)||{attributes:{}};if(_){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(d,r);t.aggregateGeometries[i]=e}else{let s=null;if(w)s=i;else{const e=this._getAttributeValues(o,f,n),t=u.map((t=>e[t]));s=x&&"statisticParameters"in d?this._getPercentileValue(d,t):this._getStatisticValue(d,t,null,o.returnDistinctValues)}t.attributes[e]=s}let s=0;c.forEach(((e,i)=>t.attributes[this.fieldsIndex.get(e)?e:"EXPR_"+ ++s]=a[i])),l.set(m,t)}}}else if(_){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(d,this.items);t.aggregateGeometries[i]=e}else{const i=this._getAttributeValues(o,f,n);t.attributes[e]=x&&"statisticParameters"in d?this._getPercentileValue(d,i):this._getStatisticValue(d,i,a,o.returnDistinctValues)}const b="min"!==u&&"max"!==u||!(0,s.ce)(this.fieldsIndex.get(f))&&!this._isAnyDateField(f)?null:this.fieldsIndex.get(f)?.type;i.push({name:e,alias:e,type:b||"esriFieldTypeDouble"})}const x=p?Array.from(l.values()):[t];return this._sortFeatures(x,d,((e,t)=>e.attributes[t])),f&&(x.length=Math.min(f,x.length)),{fields:i,features:x}}_isAnyDateField(e){const t=this.fieldsIndex.get(e);return(0,s.ag)(t)||(0,s.bH)(t)||(0,s.bI)(t)||(0,s.ap)(t)}async _getAggregateGeometry(e,t){const{convexHull:n,union:a}=await Promise.all([i.e(916),i.e(3318)]).then(i.bind(i,54752)).then((e=>e.g)),{statisticType:r,outStatisticFieldName:l}=e,{featureAdapter:o,spatialReference:u,geometryType:h,hasZ:d,hasM:f}=this,m=t.map((e=>(0,c.a)(h,d,f,o.getGeometry(e)))),p=n(u,m,!0)[0],y={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===r){const e=p?(0,s.hy)(p):(0,s.ey)(a(u,m));y.aggregateGeometries={...e,spatialReference:u},y.outStatisticFieldName=l||"extent"}else if("CentroidAggregate"===r){const e=p?(0,s.ha)(p):(0,s.hz)((0,s.ey)(a(u,m)));y.aggregateGeometries={x:e[0],y:e[1],spatialReference:u},y.outStatisticFieldName=l||"centroid"}else"ConvexHullAggregate"===r&&(y.aggregateGeometries=p,y.outStatisticFieldName=l||"convexHull");return y}_getStatisticValue(e,t,i,n){const{onStatisticField:a,statisticType:r}=e;let l=null;return l=i?.has(a)?i.get(a):(0,s.ce)(this.fieldsIndex.get(a))||this._isAnyDateField(a)?(0,p.f)({values:t,returnDistinct:n}):(0,p.p)({values:n?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,l),l["var"===r?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:n}=e,{value:a,orderBy:r}=s,l=this.fieldsIndex.get(i);return(0,p.v)(t,{value:a,orderBy:r,fieldType:l?.type,isDiscrete:"percentile_disc"===n})}_getAttributeValues(e,t,i){if(i.has(t))return i.get(t);const s=this.fieldsIndex.get(t),n=this.items.map((i=>e.getFieldValue(i,t,s)));return i.set(t,n),n}_calculateUniqueValues(e,t){const i={},s=this.items,n=s.length;for(let a=0;a<n;a++){const n=s[a],r=[];for(const t of e)r.push(t[a]);const l=r.join(",");null==i[l]?i[l]={count:1,data:r,items:[n],itemPositions:[a]}:(t||i[l].count++,i[l].items.push(n),i[l].itemPositions.push(a))}return i}async _getDataValues(e,t=!0){const i=new Q(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:n,scale:a,timeZone:r}=e;return n?i.getExpressionValues(this.items,n,{viewingMode:"map",scale:a,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},r):i.getDataValues(this.items,(0,s.f)(e),t)}}function j(e,t,i,s){const n=s.x-i.x,a=s.y-i.y,r=n*n+a*a,l=(t.x-i.x)*n+(t.y-i.y)*a,o=Math.min(1,Math.max(0,l/r));e.x=i.x+n*o,e.y=i.y+a*o}function Z(e,t){return e?t?4:3:t?3:2}class B{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}const $="unsupported-query";async function U(e,{fieldsIndex:t,geometryType:i,spatialReference:n,availableFields:a}){if((e.distance??0)<0||null!=e.geometryPrecision||e.multipatchOption&&"xyFootprint"!==e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new s.s($,"Unsupported query options",{query:e});return L(t,a,e),Y(t,a,e),Promise.all([(0,c.v)(e,i,n),(0,h.x)(n,e.outSR)]).then((()=>e))}function L(e,t,i){const{outFields:n,orderByFields:a,returnDistinctValues:r,outStatistics:l}=i,o=l?l.map((e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase())).filter(Boolean):[];if(a&&a.length>0){const s=" asc",n=" desc",r=a.map((e=>{const t=e.toLowerCase();return t.includes(s)?t.split(s)[0]:t.includes(n)?t.split(n)[0]:e})).filter((e=>!o.includes(e)));z(e,t,r,{expressionName:"orderByFields",query:i})}if(n&&n.length>0)z(e,t,n,{expressionName:"outFields",query:i,allowedFieldTypes:"all"});else if(r)throw new s.s($,"outFields should be specified for returnDistinctValues",{query:i});T(e,t,i.where,i)}const H=new Set([...b,...v]);function Y(e,t,i){const{outStatistics:n,groupByFieldsForStatistics:a,having:r}=i,l=a?.length,o=n?.length;if(r){if(!l||!o)throw new s.s($,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:i});V(e,t,r,n,i)}if(o){if(!W(n))return;const r=n.map((e=>e.onStatisticField)).filter(Boolean);z(e,t,r,{expressionName:"onStatisticFields",query:i}),l&&z(e,t,a,{expressionName:"groupByFieldsForStatistics",query:i});for(const a of n){const{onStatisticField:n,statisticType:r}=a;if("percentile_disc"!==r&&"percentile_cont"!==r||!("statisticParameters"in a))e.get(n)&&"count"!==r&&"min"!==r&&"max"!==r&&z(e,t,[n],{expressionName:`outStatistics with '${r}' statistic type`,allowedFieldTypes:H,query:i});else{const{statisticParameters:e}=a;if(!e)throw new s.s($,"statisticParameters should be set for percentile type",{definition:a,query:i})}}}}async function J(e,t,{fieldsIndex:i,geometryType:n,spatialReference:a,availableFields:r}){if((e.distance??0)<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new s.s($,"Unsupported query options",{query:e});return L(i,r,e),Promise.all([K(i,r,t,e),(0,c.v)(e,n,a),(0,h.x)(a,e.outSR)]).then((()=>e))}async function K(e,t,i,n){let a=[];if(i.valueExpression){const{arcadeUtils:e}=await(0,s.bG)();a=e.extractFieldNames(i.valueExpression)}if(i.field&&a.push(i.field),i.field2&&a.push(i.field2),i.field3&&a.push(i.field3),i.normalizationField&&a.push(i.normalizationField),!a.length&&!i.valueExpression)throw new s.s($,"field or valueExpression is required",{params:i});z(e,t,a,{expressionName:"statistics",query:n})}function W(e){return null!=e&&e.every((e=>"exceedslimit"!==e.statisticType))}const X="unsupported-query";class ee{constructor(e){this._cache=new N,this._changeHandle=null,this.capabilities={query:d.t},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,this.fieldsIndex=(0,s.aq)(e.fieldsIndex)?e.fieldsIndex:y.Z.fromJSON(e.fieldsIndex),!e.availableFields||1===e.availableFields.length&&"*"===e.availableFields[0]?this.availableFields=new Set(this.fieldsIndex.fields.map((e=>e.name))):this.availableFields=new Set(e.availableFields.map((e=>this.fieldsIndex.get(e)?.name)).filter((e=>null!=e))),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=(0,s.aJ)(this._frameTask),this.clearCache(),(0,s.C)(this._cache),this._changeHandle=(0,s.aJ)(this._changeHandle)}get featureAdapter(){return this.featureStore.featureAdapter}clearCache(){this._cache.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async executeQuery(e,t){const i=(0,s.hA)(t);try{return await(await this._executeQuery(e,{},i)).createQueryResponse()}catch(n){if(n!==h.g)throw n;return new k([],e,this).createQueryResponse()}}async executeQueryForCount(e={},t){const i=(0,s.hA)(t);try{return(await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},i)).createQueryResponseForCount()}catch(n){if(n!==h.g)throw n;return 0}}async executeQueryForExtent(e,t){const i=(0,s.hA)(t),n=e.outSR;try{const t=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},i),s=t.size;return s?{count:s,extent:await this._getBounds(t.items,t.spatialReference,n||this.spatialReference)}:{count:0,extent:null}}catch(a){if(a===h.g)return{count:0,extent:null};throw a}}async executeQueryForIds(e,t){return this.executeQueryForIdSet(e,t).then((e=>Array.from(e)))}async executeQueryForIdSet(e,t){const i=(0,s.hA)(t);try{const t=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},i),s=t.items,n=new Set;return await this._reschedule((()=>{for(const e of s)n.add(t.featureAdapter.getObjectId(e))}),i),n}catch(n){if(n===h.g)return new Set;throw n}}async executeQueryForSnapping(e,t){const i=(0,s.hA)(t),{point:n,distance:r,returnEdge:l,vertexMode:o}=e;if(!l&&"none"===o)return{candidates:[]};let u=(0,s.f)(e.query);u=await this._schedule((()=>(0,h.a)(u,this.definitionExpression,this.spatialReference)),i),u=await this._reschedule((()=>U(u,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i);const c=!(0,s.bh)(n.spatialReference,this.spatialReference);c&&await(0,h.x)(n.spatialReference,this.spatialReference);const d="number"==typeof r?r:r.x,f="number"==typeof r?r:r.y,m={xmin:n.x-d,xmax:n.x+d,ymin:n.y-f,ymax:n.y+f,spatialReference:n.spatialReference},p=c?(0,h.j)(m,this.spatialReference):m;if(!p)return{candidates:[]};const y=(await(0,a.R)((0,s.b3)(n),null,{signal:i}))[0],g=(await(0,a.R)((0,s.b3)(p),null,{signal:i}))[0];if(null==y||null==g)return{candidates:[]};const x=new k(await this._reschedule((()=>this._searchFeatures(te(g.toJSON()))),i),u,this);await this._reschedule((()=>this._executeObjectIdsQuery(x)),i),await this._reschedule((()=>this._executeTimeQuery(x)),i),await this._reschedule((()=>this._executeAttributesQuery(x)),i),await this._reschedule((()=>this._executeGeometryQueryForSnapping(x,i)),i);const F=y.toJSON(),_=c?(0,h.j)(F,this.spatialReference):F,w=c?Math.max(p.xmax-p.xmin,p.ymax-p.ymin)/2:r;return x.createSnappingResponse({...e,point:_,distance:w},n.spatialReference)}async executeQueryForLatestObservations(e,t){const i=(0,s.hA)(t);if(!this.timeInfo?.trackIdField)throw new s.s(X,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const t=await this._executeQuery(e,{},i);return await this._reschedule((()=>this._filterLatest(t)),i),await t.createQueryResponse()}catch(n){if(n!==h.g)throw n;return new k([],e,this).createQueryResponse()}}async executeQueryForSummaryStatistics(e={},t,i){const n=(0,s.hA)(i),{field:a,normalizationField:r,valueExpression:l}=t;return(await this._executeQueryForStatistics(e,{field:a,normalizationField:r,valueExpression:l},n)).createSummaryStatisticsResponse(t)}async executeQueryForUniqueValues(e={},t,i){const n=(0,s.hA)(i),{field:a,field2:r,field3:l,valueExpression:o}=t;return(await this._executeQueryForStatistics(e,{field:a,field2:r,field3:l,valueExpression:o},n)).createUniqueValuesResponse(t)}async executeQueryForClassBreaks(e={},t,i){const n=(0,s.hA)(i),{field:a,normalizationField:r,valueExpression:l}=t;return(await this._executeQueryForStatistics(e,{field:a,normalizationField:r,valueExpression:l},n)).createClassBreaksResponse(t)}async executeQueryForHistogram(e={},t,i){const n=(0,s.hA)(i),{field:a,normalizationField:r,valueExpression:l}=t;return(await this._executeQueryForStatistics(e,{field:a,normalizationField:r,valueExpression:l},n)).createHistogramResponse(t)}async fetchRecomputedExtents(e){const t=(0,s.hA)(e);this._timeExtentPromise||=(0,c.b)(this.timeInfo,this.featureStore);const[i,n]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return(0,s.D)(t),{fullExtent:i,timeExtent:n}}async _getBounds(e,t,i){const n=(0,s.hB)((0,s.bO)(),s.cS);await this.featureStore.forEachBounds(e,(e=>(0,s.cU)(n,e)));const a={xmin:n[0],ymin:n[1],xmax:n[3],ymax:n[4],spatialReference:(0,c.h)(this.spatialReference)};this.hasZ&&isFinite(n[2])&&isFinite(n[5])&&(a.zmin=n[2],a.zmax=n[5],a.hasZ=!0);const r=(0,h.j)(a,t,i);if(r.spatialReference=(0,c.h)(i),r.xmax-r.xmin==0){const e=(0,s.bq)(r.spatialReference);r.xmin-=e,r.xmax+=e}if(r.ymax-r.ymin==0){const e=(0,s.bq)(r.spatialReference);r.ymin-=e,r.ymax+=e}if(this.hasZ&&null!=r.zmin&&null!=r.zmax&&r.zmax-r.zmin==0){const e=(0,s.bq)(r.spatialReference);r.zmin-=e,r.zmax+=e}return r}_getFullExtent(){return this._fullExtentPromise||="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then((e=>this._getBounds(e,this.spatialReference,this.spatialReference))),this._fullExtentPromise}async _schedule(e,t){return null!=this._frameTask?this._frameTask.schedule(e,t):e(g.C)}async _reschedule(e,t){return null!=this._frameTask?this._frameTask.reschedule(e,t):e(g.C)}async _getAllFeaturesQueryEngineResult(e){return new k(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(null==this._allFeaturesPromise){const e=[];this._allFeaturesPromise=(async()=>{await this.featureStore.forEach((t=>e.push(t)))})().then((()=>e))}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async _executeQuery(e,t,i){e=(0,s.f)(e),e=await this._schedule((()=>(0,h.S)(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>U(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i),e={...e,...t};const n=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),a=await this._reschedule((()=>this._executeGeometryQuery(e,n,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(a)),i),await this._reschedule((()=>this._executeObjectIdsQuery(a)),i),await this._reschedule((()=>this._executeTimeQuery(a)),i),await this._reschedule((()=>this._executeAttributesQuery(a)),i),a}async _executeSceneFilterQuery(e,t){if(null==e.sceneFilter)return null;const{outSR:i,returnGeometry:n,returnCentroid:a}=e,r=this.featureStore.featureSpatialReference,l=e.sceneFilter.geometry,o=null==r||(0,s.bh)(r,l.spatialReference)?l:(0,h.j)(l,r);if(!o)return null;const u=n||a,d=(0,s.cg)(i)&&!(0,s.bh)(this.spatialReference,i)&&u?async e=>this._project(e,i):e=>e,f=this.featureAdapter,m=await this._reschedule((()=>this._searchFeatures(te(o))),t);if("disjoint"===e.sceneFilter.spatialRelationship){if(!m.length)return null;const i=new Set;for(const e of m)i.add(f.getObjectId(e));const s=await this._reschedule((()=>this._getAllFeatures()),t),n=await this._reschedule((async()=>{const n=await(0,c.P)("esriSpatialRelDisjoint",o,this.geometryType,this.hasZ,this.hasM),a=e=>!i.has(f.getObjectId(e))||n(f.getGeometry(e)),r=await this._runSpatialFilter(s,a,t);return new k(r,e,this)}),t);return d(n)}if(!m.length)return new k([],e,this);if(this._canExecuteSinglePass(o,e))return d(new k(m,e,this));const p=await(0,c.P)("esriSpatialRelContains",o,this.geometryType,this.hasZ,this.hasM),y=await this._runSpatialFilter(m,(e=>p(f.getGeometry(e))),t);return d(new k(y,e,this))}async _executeGeometryQuery(e,t,i){if(null!=t&&0===t.items.length)return t;e=null!=t?t.query:e;const{geometry:n,outSR:a,spatialRel:r,returnGeometry:l,returnCentroid:o}=e,u=this.featureStore.featureSpatialReference,d=!n||null==u||(0,s.bh)(u,n.spatialReference)?n:(0,h.j)(n,u),f=l||o,m=(0,s.cg)(a)&&!(0,s.bh)(this.spatialReference,a),p=null==t?this._getCacheKey(e):null,y=p?this._cache.get(p):null;if(null!=y)return new k(y,e,this);const g=async e=>(m&&f&&await this._project(e,a),p&&this._cache.put(p,e.items),e);if(!d)return g(t??await this._getAllFeaturesQueryEngineResult(e));const x=this.featureAdapter;let F=await this._reschedule((()=>this._searchFeatures(te(n))),i);if("esriSpatialRelDisjoint"===r){if(!F.length)return g(t??await this._getAllFeaturesQueryEngineResult(e));const s=new Set;for(const e of F)s.add(x.getObjectId(e));const n=null!=t?t.items:await this._reschedule((()=>this._getAllFeatures()),i),a=await this._reschedule((async()=>{const t=await(0,c.P)(r,d,this.geometryType,this.hasZ,this.hasM),a=e=>!s.has(x.getObjectId(e))||t(x.getGeometry(e)),l=await this._runSpatialFilter(n,a,i);return new k(l,e,this)}),i);return g(a)}if(null!=t){const e=new s.bZ;F=F.filter((i=>(0,s.bY)(t.items,i,t.items.length,e)>=0))}if(!F.length){const t=new k([],e,this);return p&&this._cache.put(p,t.items),t}if(this._canExecuteSinglePass(d,e))return g(new k(F,e,this));const _=await(0,c.P)(r,d,this.geometryType,this.hasZ,this.hasM),w=await this._runSpatialFilter(F,(e=>_(x.getGeometry(e))),i);return g(new k(w,e,this))}async _executeGeometryQueryForSnapping(e,t){const{query:i}=e,{spatialRel:s}=i;if(!e?.items?.length||!i.geometry||!s)return;const n=await(0,c.P)(s,i.geometry,this.geometryType,this.hasZ,this.hasM),a=await this._runSpatialFilter(e.items,(e=>n(e.geometry)),t);e.items=a}_executeAggregateIdsQuery(e){if(0===e.items.length||!e.query.aggregateIds?.length||null==this.aggregateAdapter)return;const t=new Set;for(const s of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(s).forEach((e=>t.add(e)));const i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))))}_executeObjectIdsQuery(e){if(0===e.items.length||!e.query.objectIds?.length)return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))))}_executeTimeQuery(e){if(0===e.items.length)return;const t=(0,c.t)(this.timeInfo,e.query.timeExtent,this.featureAdapter);null!=t&&(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(0===e.items.length)return;const t=R(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter((e=>t.testFeature(e,this.featureAdapter)))}}async _runSpatialFilter(e,t,i){if(!t)return e;if(null==this._frameTask)return e.filter((e=>t(e)));let s=0;const n=new Array,a=async r=>{for(;s<e.length;){const l=e[s++];t(l)&&(n.push(l),r.madeProgress()),r.done&&await this._reschedule((e=>a(e)),i)}};return this._reschedule((e=>a(e)),i).then((()=>n))}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:s}=this.timeInfo,n=s||i,a=new Map,r=this.featureAdapter.getAttribute;for(const l of e.items){const e=r(l,t),i=r(l,n),s=a.get(e);(!s||i>r(s,n))&&a.set(e,l)}e.items=Array.from(a.values())}_getCacheKey(e){const{geometry:t,spatialRel:i,returnGeometry:n,returnCentroid:a,outSR:r,resultType:l,cacheHint:o}=e;if("tile"!==l&&!o)return null;const u=n||a;return(0,s.cg)(r)&&!(0,s.bh)(this.spatialReference,r)&&u?JSON.stringify([t,i,r]):JSON.stringify([t,i])}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return(0,c.I)(e)&&("esriSpatialRelEnvelopeIntersects"===i||"esriGeometryPoint"===this.geometryType&&("esriSpatialRelIntersects"===i||"esriSpatialRelContains"===i))}async _project(e,t){if(!t||(0,s.bh)(this.spatialReference,t))return e;const i=this.featureAdapter;let a;try{const e=await this._getFullExtent();a=(0,n.Y)(this.spatialReference,t,e)}catch{}const l=await(0,h.b)(e.items.map((e=>(0,c.a)(this.geometryType,this.hasZ,this.hasM,i.getGeometry(e)))),this.spatialReference,t,a);return e.items=l.map(((t,s)=>i.cloneWithGeometry(e.items[s],(0,r.o)(t,this.hasZ,this.hasM)))),e}async _searchFeatures(e){const t=new Set;await Promise.all(e.map((e=>this.featureStore.forEachInBounds(e,(e=>t.add(e))))));const i=Array.from(t.values());return t.clear(),i}async _executeQueryForStatistics(e,t,i){e=(0,s.f)(e);try{e=await this._schedule((()=>(0,h.S)(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>J(e,t,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i);const s=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),n=await this._reschedule((()=>this._executeGeometryQuery(e,s,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(n)),i),await this._reschedule((()=>this._executeObjectIdsQuery(n)),i),await this._reschedule((()=>this._executeTimeQuery(n)),i),await this._reschedule((()=>this._executeAttributesQuery(n)),i),n}catch(n){if(n!==h.g)throw n;return new k([],e,this)}}}function te(e){if((0,c.I)(e)){if((0,s.cJ)(e))return[(0,s.ae)(Math.min(e.xmin,e.xmax),Math.min(e.ymin,e.ymax),Math.max(e.xmin,e.xmax),Math.max(e.ymin,e.ymax))];if((0,s.a9)(e))return e.rings.map((e=>(0,s.ae)(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return[(0,s.cM)((0,s.bS)(),e)]}},94706:function(e,t,i){i.d(t,{t:function(){return s}});const s={supportsStatistics:!0,supportsPercentileStatistics:!0,supportsSpatialAggregationStatistics:!1,supportedSpatialAggregationStatistics:{envelope:!1,centroid:!1,convexHull:!1},supportsCentroid:!0,supportsCacheHint:!0,supportsDistance:!0,supportsDistinct:!0,supportsExtent:!0,supportsGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQuantization:!0,supportsQuantizationEditMode:!1,supportsQueryGeometry:!0,supportsResultType:!0,supportsSqlExpression:!0,supportsMaxRecordCountFactor:!1,supportsStandardizedQueriesOnly:!0,supportsTopFeaturesQuery:!1,supportsQueryByAnonymous:!0,supportsQueryByOthers:!0,supportsHistoricMoment:!1,supportsFormatPBF:!1,supportsDisjointSpatialRelationship:!0,supportsDefaultSpatialReference:!1,supportsFullTextSearch:!1,supportsCompactGeometry:!1,maxRecordCountFactor:void 0,maxRecordCount:void 0,standardMaxRecordCount:void 0,tileMaxRecordCount:void 0}},35513:function(e,t,i){i.d(t,{a:function(){return o},c:function(){return r},e:function(){return l},f:function(){return c},l:function(){return h},u:function(){return d}});var s=i(98503),n=i(90211),a=i(83448);const r=2.4;function l(e){return(0,s.bd)(e*r)}function o(e){return(0,s.be)(e)/r}function u(e,t,i,a){let{color:r,ratio:l}=t,{color:o,ratio:u}=i;u===l&&(1===u?l-=1e-6:u+=1e-6);const c=(0,s.aP)((a-l)/(u-l),0,1);(0,n._)(e,r.toArray(),o.toArray(),c)}function c(e){const t=new Uint8ClampedArray(2048);if(e=e.filter((({ratio:e})=>e>=0&&e<=1)).sort(((e,t)=>e.ratio-t.ratio)).map((({color:e,ratio:t})=>({color:e,ratio:Math.max(t,.001)}))),e.length<1)return t;let i=e[0],s=e[0],n=1;const r=(0,a.n)();for(let a=0;a<512;a++){const l=(a+.5)/512;for(;l>s.ratio&&n<e.length;)i=s,s=e[n++];u(r,i,s,l),t.set(r,4*a)}return t}function h(e,t,i){const s=Math.sqrt(e**2+t**2)/i;return s>1?0:3/(Math.PI*i**2)*(1-s**2)**2}function d(e){return"function"==typeof e?e:e?t=>+t[e]:()=>1}},55605:function(e,t,i){i.d(t,{$:function(){return Y},B:function(){return J},C:function(){return U},E:function(){return K},P:function(){return ee},U:function(){return te},d:function(){return R},f:function(){return M},g:function(){return C},k:function(){return L},m:function(){return V},p:function(){return A},v:function(){return z}});var s=i(97920),n=i(98503);const a=()=>n.n.getLogger("esri.rest.support.generateRendererUtils");function r(e,t){return Number(e.toFixed(t))}function l(e){const{normalizationTotal:t}=e;return{classBreaks:o(e),normalizationTotal:t}}function o(e){const t=e.definition,{classificationMethod:i,normalizationType:s,definedInterval:n}=t,a=t.breakCount??1,l=[];let o=e.values;if(0===o.length)return[];o=o.sort(((e,t)=>e-t));const d=o[0],f=o[o.length-1];if("equal-interval"===i)if(o.length>=a){const e=(f-d)/a;let t=d;for(let i=1;i<a;i++){const n=r(d+i*e,6);l.push({minValue:t,maxValue:n,label:u(t,n,s)}),t=n}l.push({minValue:t,maxValue:f,label:u(t,f,s)})}else o.forEach((e=>{l.push({minValue:e,maxValue:e,label:u(e,e,s)})}));else if("natural-breaks"===i){const t=c(o),i=e.valueFrequency||t.valueFrequency,n=h(t.uniqueValues,i,a);let m=d;for(let e=1;e<a;e++)if(t.uniqueValues.length>e){const i=r(t.uniqueValues[n[e]],6);l.push({minValue:m,maxValue:i,label:u(m,i,s)}),m=i}l.push({minValue:m,maxValue:f,label:u(m,f,s)})}else if("quantile"===i)if(o.length>=a&&d!==f){let e=d,t=Math.ceil(o.length/a),i=0;for(let n=1;n<a;n++){let r=t+i-1;r>o.length&&(r=o.length-1),r<0&&(r=0),l.push({minValue:e,maxValue:o[r],label:u(e,o[r],s)}),e=o[r],i+=t,t=Math.ceil((o.length-i)/(a-n))}l.push({minValue:e,maxValue:f,label:u(e,f,s)})}else{let e=-1;for(let t=0;t<o.length;t++){const i=o[t];i!==e&&(e=i,l.push({minValue:e,maxValue:i,label:u(e,i,s)}),e=i)}}else if("standard-deviation"===i){const e=p(o),t=y(o,e);if(0===t)l.push({minValue:o[0],maxValue:o[0],label:u(o[0],o[0],s)});else{const i=m(d,f,a,e,t)*t;let n=0,o=d;for(let t=a;t>=1;t--){const a=r(e-(t-.5)*i,6);l.push({minValue:o,maxValue:a,label:u(o,a,s)}),o=a,n++}let c=r(e+.5*i,6);l.push({minValue:o,maxValue:c,label:u(o,c,s)}),o=c,n++;for(let t=1;t<=a;t++)c=n===2*a?f:r(e+(t+.5)*i,6),l.push({minValue:o,maxValue:c,label:u(o,c,s)}),o=c,n++}}else if("defined-interval"===i){if(!n)return l;const e=o[0],t=o[o.length-1],i=Math.ceil((t-e)/n);let a=e;for(let o=1;o<i;o++){const t=r(e+o*n,6);l.push({minValue:a,maxValue:t,label:u(a,t,s)}),a=t}l.push({minValue:a,maxValue:t,label:u(a,t,s)})}return l}function u(e,t,i){let s=null;return s=e===t?i&&"percent-of-total"===i?e+"%":e.toString():i&&"percent-of-total"===i?e+"% - "+t+"%":e+" - "+t,s}function c(e){const t=[],i=[];let s=Number.MIN_VALUE,n=1,a=-1;for(let r=0;r<e.length;r++){const l=e[r];l===s?(n++,i[a]=n):null!==l&&(t.push(l),s=l,n=1,i.push(n),a++)}return{uniqueValues:t,valueFrequency:i}}function h(e,t,i){const s=e.length,n=[];i>s&&(i=s);for(let r=0;r<i;r++)n.push(Math.round(r*s/i-1));n.push(s-1);let a=d(n,e,t,i);return f(a.mean,a.sdcm,n,e,t,i)&&(a=d(n,e,t,i)),n}function d(e,t,i,s){let n=[],a=[],r=[],l=0;const o=[],u=[];for(let f=0;f<s;f++){const s=g(f,e,t,i);o.push(s.sbMean),u.push(s.sbSdcm),l+=u[f]}let c,h=l,d=!0;for(;d||l<h;){d=!1,n=[];for(let t=0;t<s;t++)n.push(e[t]);for(let i=0;i<s;i++)for(let n=e[i]+1;n<=e[i+1];n++)if(c=t[n],i>0&&n!==e[i+1]&&Math.abs(c-o[i])>Math.abs(c-o[i-1]))e[i]=n;else if(i<s-1&&e[i]!==n-1&&Math.abs(c-o[i])>Math.abs(c-o[i+1])){e[i+1]=n-1;break}h=l,l=0,a=[],r=[];for(let n=0;n<s;n++){a.push(o[n]),r.push(u[n]);const s=g(n,e,t,i);o[n]=s.sbMean,u[n]=s.sbSdcm,l+=u[n]}}if(l>h){for(let t=0;t<s;t++)e[t]=n[t],o[t]=a[t],u[t]=r[t];l=h}return{mean:o,sdcm:u}}function f(e,t,i,s,n,a){let r=0,l=0,o=0,u=0,c=!0;for(let h=0;h<2&&c;h++){0===h&&(c=!1);for(let h=0;h<a-1;h++)for(;i[h+1]+1!==i[h+2];){i[h+1]=i[h+1]+1;const a=g(h,i,s,n);o=a.sbMean,r=a.sbSdcm;const d=g(h+1,i,s,n);if(u=d.sbMean,l=d.sbSdcm,!(r+l<t[h]+t[h+1])){i[h+1]=i[h+1]-1;break}t[h]=r,t[h+1]=l,e[h]=o,e[h+1]=u,c=!0}for(let h=a-1;h>0;h--)for(;i[h]!==i[h-1]+1;){i[h]=i[h]-1;const a=g(h-1,i,s,n);o=a.sbMean,r=a.sbSdcm;const d=g(h,i,s,n);if(u=d.sbMean,l=d.sbSdcm,!(r+l<t[h-1]+t[h])){i[h]=i[h]+1;break}t[h-1]=r,t[h]=l,e[h-1]=o,e[h]=u,c=!0}}return c}function m(e,t,i,s,n){let a=Math.max(s-e,t-s)/n/i;return a=a>=1?1:a>=.5?.5:.25,a}function p(e){let t=0;for(let i=0;i<e.length;i++)t+=e[i];return t/=e.length,t}function y(e,t){let i=0;for(let s=0;s<e.length;s++){const n=e[s];i+=(n-t)*(n-t)}return i/=e.length,Math.sqrt(i)}function g(e,t,i,s){let n=0,r=0;for(let a=t[e]+1;a<=t[e+1];a++){const e=s[a];n+=i[a]*e,r+=e}r<=0&&a().warn("Exception in Natural Breaks calculation");const l=n/r;let o=0;for(let a=t[e]+1;a<=t[e+1];a++)o+=s[a]*(i[a]-l)**2;return{sbMean:l,sbSdcm:o}}const x="<Null>",F="equal-interval",_=1,w=5,b=10,v=/\s*(\+|-)?((\d+(\.\d+)?)|(\.\d+))\s*/gi,I=new Set(["esriFieldTypeDate","esriFieldTypeInteger","esriFieldTypeSmallInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeOID","esriFieldTypeBigInteger"]),S=new Set(["esriFieldTypeTimeOnly","esriFieldTypeDateOnly"]),T=["min","max","avg","stddev","count","sum","variance","nullcount","median"];function V(e){return null==e||"string"==typeof e&&!e?x:e}function R(e){const t=null!=e.normalizationField||null!=e.normalizationType,i=null!=e.minValue||null!=e.maxValue,s=!!e.sqlExpression&&e.supportsSQLExpression;return!t&&!i&&!s}function M(e){const{outStatisticTypes:t}=e,i=e.returnDistinct?[...new Set(e.values)]:e.values,s=i.filter((e=>null!=e)).sort(),n=s.length,a={count:n,min:s[0],max:s[n-1]};return e.supportsNullCount&&(a.nullcount=i.length-n),!e.percentileParams||t?.include?.length&&!t.include.includes("median")||t?.exclude?.length&&t.exclude.includes("median")||(a.median=z(i,e.percentileParams)),a}function A(e){const{values:t,useSampleStdDev:i,supportsNullCount:s,outStatisticTypes:n}=e;let a=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY,l=null,o=null,u=null,c=null,h=0;const d=null==e.minValue?-1/0:e.minValue,f=null==e.maxValue?1/0:e.maxValue;for(const p of t)Number.isFinite(p)?p>=d&&p<=f&&(l=null===l?p:l+p,a=Math.min(a,p),r=Math.max(r,p),h++):"string"==typeof p&&h++;if(h&&null!=l){o=l/h;let e=0;for(const i of t)Number.isFinite(i)&&i>=d&&i<=f&&(e+=(i-o)**2);c=i?h>1?e/(h-1):0:h>0?e/h:0,u=Math.sqrt(c)}else a=null,r=null;const m={avg:o,count:h,max:r,min:a,stddev:u,sum:l,variance:c};return s&&(m.nullcount=t.length-h),!e.percentileParams||n?.include?.length&&!n.include.includes("median")||n?.exclude?.length&&n.exclude.includes("median")||(m.median=z(t,e.percentileParams)),m}function z(e,t){const{fieldType:i,value:s,orderBy:n,isDiscrete:a}=t,r=C(i,"desc"===n);if(0===(e=[...e].filter((e=>null!=e)).sort(((e,t)=>r(e,t)))).length)return null;if(s<=0)return e[0];if(s>=1)return e[e.length-1];const l=(e.length-1)*s,o=Math.floor(l),u=o+1,c=l%1,h=e[o],d=e[u];return u>=e.length||a||"string"==typeof h||"string"==typeof d?h:h*(1-c)+d*c}function C(e,t){if(e){if(I.has(e))return B(t);if(S.has(e))return k(t,!1);if("esriFieldTypeTimestampOffset"===e)return Q(t);const i=k(t,!0);if("esriFieldTypeString"===e)return i;if("esriFieldTypeGUID"===e||"esriFieldTypeGlobalID"===e)return(e,t)=>i($(e),$(t))}const i=t?1:-1,s=B(t),n=k(t,!0),a=N(t);return(e,t)=>"number"==typeof e&&"number"==typeof t?s(e,t):"string"==typeof e&&"string"==typeof t?n(e,t):a(e,t)??i}const D=(e,t)=>null==e?null==t?0:1:null==t?-1:null,E=(e,t)=>null==e?null==t?0:-1:null==t?1:null;function N(e){return e?D:E}const q=(e,t)=>E(e,t)??(e===t?0:new Date(e).getTime()-new Date(t).getTime()),P=(e,t)=>D(e,t)??(e===t?0:new Date(t).getTime()-new Date(e).getTime());function Q(e){return e?P:q}const G=(e,t)=>E(e,t)??(e===t?0:e<t?-1:1),O=(e,t)=>D(e,t)??(e===t?0:e<t?1:-1);function k(e,t){if(!t)return e?O:G;const i=N(e);return e?(e,t)=>i(e,t)??((e=e.toUpperCase())>(t=t.toUpperCase())?-1:e<t?1:0):(e,t)=>i(e,t)??((e=e.toUpperCase())<(t=t.toUpperCase())?-1:e>t?1:0)}const j=(e,t)=>D(e,t)??t-e,Z=(e,t)=>E(e,t)??e-t;function B(e){return e?j:Z}function $(e){return e.slice(24,36)+e.slice(19,23)+e.slice(16,18)+e.slice(14,16)+e.slice(11,13)+e.slice(9,11)+e.slice(6,8)+e.slice(4,6)+e.slice(2,4)+e.slice(0,2)}function U(e,t,i){let s;for(s in e)t?.include?.length&&!t.include.includes(s)||t?.exclude?.length&&t.exclude.includes(s)?delete e[s]:T.includes(s)&&(Number.isFinite(e[s])||(e[s]=null));return i&&["avg","stddev","variance"].forEach((t=>{null!=e[t]&&(e[t]=Math.ceil(e[t]??0))})),e}function L(e){const t={};for(let i of e)(null==i||"string"==typeof i&&""===i.trim())&&(i=null),null==t[i]?t[i]={count:1,data:i}:t[i].count++;return{count:t}}function H(e){return"coded-value"!==e?.type?[]:e.codedValues.map((e=>e.code))}function Y(e,t,i,s){const n=e.count,a=[];if(i&&t){const e=[],i=H(t[0]);for(const n of i)if(t[1]){const i=H(t[1]);for(const a of i)if(t[2]){const i=H(t[2]);for(const t of i)e.push(`${V(n)}${s}${V(a)}${s}${V(t)}`)}else e.push(`${V(n)}${s}${V(a)}`)}else e.push(n);for(const t of e)n.hasOwnProperty(t)||(n[t]={data:t,count:0})}for(const r in n){const e=n[r];a.push({value:e.data,count:e.count,label:e.label})}return{uniqueValueInfos:a}}function J(e,t,i,s){let n=null;switch(t){case"log":0!==e&&(n=Math.log(e)*Math.LOG10E);break;case"percent-of-total":Number.isFinite(s)&&0!==s&&(n=e/s*100);break;case"field":Number.isFinite(i)&&0!==i&&(n=e/i);break;case"natural-log":e>0&&(n=Math.log(e));break;case"square-root":e>0&&(n=e**.5)}return n}function K(e,t){const i=X({field:t.field,normalizationType:t.normalizationType,normalizationField:t.normalizationField,classificationMethod:t.classificationMethod,standardDeviationInterval:t.standardDeviationInterval,breakCount:t.numClasses||w});return e=W(e,t.minValue,t.maxValue),l({definition:i,values:e,normalizationTotal:t.normalizationTotal})}function W(e,t,i){const s=t??-1/0,n=i??1/0;return e.filter((e=>Number.isFinite(e)&&e>=s&&e<=n))}function X(e){const{breakCount:t,field:i,normalizationField:n,normalizationType:a}=e,r=e.classificationMethod||F,l="standard-deviation"===r?e.standardDeviationInterval||_:void 0,o="defined-interval"===r?e.definedInterval:void 0;return new s.d({breakCount:t,classificationField:i,classificationMethod:r,normalizationField:"field"===a?n:void 0,normalizationType:a,standardDeviationInterval:l,definedInterval:o})}function ee(e,t){let i=e.classBreaks;const s=i.length,n=i[0]?.minValue,a=i[s-1]?.maxValue,r="standard-deviation"===t,l=v;return i=i.map((e=>{const t=e.label,i={minValue:e.minValue,maxValue:e.maxValue,label:t};if(r&&t){const e=t.match(l),s=e?.map((e=>+e.trim()))??[];2===s.length?(i.minStdDev=s[0],i.maxStdDev=s[1],s[0]<0&&s[1]>0&&(i.hasAvg=!0)):1===s.length&&(t.includes("<")?(i.minStdDev=null,i.maxStdDev=s[0]):t.includes(">")&&(i.minStdDev=s[0],i.maxStdDev=null))}return i})),{minValue:n,maxValue:a,classBreakInfos:i,normalizationTotal:e.normalizationTotal}}function te(e,t){const i=ie(e,t);if(null==i.min&&null==i.max)return{bins:[],minValue:i.min,maxValue:i.max,normalizationTotal:t.normalizationTotal};const s=i.intervals,n=i.min??0,a=i.max??0,r=s.map(((e,t)=>({minValue:s[t][0],maxValue:s[t][1],count:0})));for(const l of e)if(null!=l&&l>=n&&l<=a){const e=se(s,l);e>-1&&r[e].count++}return{bins:r,minValue:n,maxValue:a,normalizationTotal:t.normalizationTotal}}function ie(e,t){const{field:i,classificationMethod:s,standardDeviationInterval:n,normalizationType:a,normalizationField:r,normalizationTotal:l,minValue:o,maxValue:u}=t,c=t.numBins||b;let h=null,d=null,f=null;if(s&&"equal-interval"!==s||a){const{classBreaks:t}=K(e,{field:i,normalizationType:a,normalizationField:r,normalizationTotal:l,classificationMethod:s,standardDeviationInterval:n,minValue:o,maxValue:u,numClasses:c});h=t[0].minValue,d=t[t.length-1].maxValue,f=t.map((e=>[e.minValue,e.maxValue]))}else{if(null!=o&&null!=u)h=o,d=u;else{const t=A({values:e,minValue:o,maxValue:u,useSampleStdDev:!a,supportsNullCount:R({normalizationType:a,normalizationField:r,minValue:o,maxValue:u})});h=t.min??null,d=t.max??null}f=ne(h??0,d??0,c)}return{min:h,max:d,intervals:f}}function se(e,t){let i=-1;for(let s=e.length-1;s>=0;s--)if(t>=e[s][0]){i=s;break}return i}function ne(e,t,i){const s=(t-e)/i,n=[];let a,r=e;for(let l=1;l<=i;l++)a=r+s,a=Number(a.toFixed(16)),n.push([r,l===i?t:a]),r=a;return n}},88736:function(e,t,i){i.d(t,{$:function(){return n},j:function(){return a}});var s=i(98503);i(96510),i(92113),i(74362);function n(e){return(0,s.ag)(e)||(0,s.bH)(e)||(0,s.bI)(e)}function a(e,t){const{format:i,timeZoneOptions:n,fieldType:a}=t??{};let r,l;if(n&&({timeZone:r,timeZoneName:l}=(0,s.bJ)(n.layerTimeZone,n.datesInUnknownTimezone,n.viewTimeZone,(0,s.bK)(i||"short-date-short-time"),a)),"string"==typeof e&&isNaN(Date.parse("time-only"===a?`1970-01-01T${e}Z`:e)))return e;switch(a){case"date-only":{const t=(0,s.bK)(i||"short-date");return"string"==typeof e?(0,s.bN)(e,{...t}):(0,s.j)(e,{...t,timeZone:s.al})}case"time-only":{const t=(0,s.bK)(i||"short-time");return"string"==typeof e?(0,s.bM)(e,t):(0,s.j)(e,{...t,timeZone:s.al})}case"timestamp-offset":{if(!r&&"string"==typeof e&&new Date(e).toISOString()!==e)return e;const t=i||n?(0,s.bK)(i||"short-date-short-time"):void 0,a=t?{...t,timeZone:r,timeZoneName:l}:void 0;return"string"==typeof e?(0,s.bL)(e,a):(0,s.j)(e,a)}default:{const t=i||n?(0,s.bK)(i||"short-date-short-time"):void 0;return(0,s.j)("string"==typeof e?new Date(e):e,t?{...t,timeZone:r,timeZoneName:l}:void 0)}}}},75412:function(e,t,i){i.d(t,{I:function(){return m},b:function(){return p},w:function(){return f},x:function(){return d}});var s=i(98503),n=i(50257),a=i(8891),r=i(35513),l=i(88736),o=i(55605);let u=null;const c=/^(?<hh>([0-1][0-9])|([2][0-3])):(?<mm>[0-5][0-9])(:(?<ss>[0-5][0-9]))?([.](?<ms>\d+))?$/;function h(e,t,i){return e.x<0?e.x+=t:e.x>i&&(e.x-=t),e}function d(e,t,i,n){const r=(0,s.bE)(i)?(0,s.bF)(i):null,l=r?Math.round((r.valid[1]-r.valid[0])/t.scale[0]):null;return e.map((e=>{const i=new s.bv(e.geometry);return(0,a.j)(t,i,i),e.geometry=r?h(i,l??0,n[0]):i,e}))}function f(e,t=18,i,n,a){const l=new Float64Array(n*a);t=Math.round((0,s.be)(t));let o=Number.POSITIVE_INFINITY,u=Number.NEGATIVE_INFINITY;const c=(0,r.u)(i);for(const{geometry:s,attributes:h}of e){const{x:e,y:i}=s,d=Math.max(0,e-t),f=Math.max(0,i-t),m=Math.min(a,i+t),p=Math.min(n,e+t),y=+c(h);for(let s=f;s<m;s++)for(let a=d;a<p;a++){const c=s*n+a,h=(0,r.l)(a-e,s-i,t)*y,d=l[c]+=h;o=Math.min(o,d),u=Math.max(u,d)}}return{min:o,max:u}}function m(e){const t=c.exec(e);if(!t)return null;const{hh:i,mm:s,ss:a,ms:r}=t.groups;return Number(i)*n.r.hours+Number(s)*n.r.minutes+Number(a)*n.r.seconds+Number(r||0)}async function p(e,t,i=!0){if(!t)return[];const{field:n,field2:a,field3:r,fieldDelimiter:c,fieldInfos:h,timeZone:d}=e,f=n&&h?.find((e=>e.name.toLowerCase()===n.toLowerCase())),p=!!f&&(0,s.ap)(f),y=!!f&&(0,l.$)(f),g=e.valueExpression,x=e.normalizationType,F=e.normalizationField,_=e.normalizationTotal,w=[],b=e.viewInfoParams;let v=null,I=null;if(g){if(!u){const{arcadeUtils:e}=await(0,s.bG)();u=e}u.hasGeometryOperations(g)&&await u.enableGeometryOperations(),v=u.createFunction(g),I=b?u.getViewInfo({viewingMode:b.viewingMode,scale:b.scale,spatialReference:new s.B(b.spatialReference)}):null}const S=e.fieldInfos,T=t[0]&&"declaredClass"in t[0]&&"esri.Graphic"===t[0].declaredClass||!S?null:{fields:S};return t.forEach((e=>{const t=e.attributes;let s;if(g){const t=T?{...e,layer:T}:e,i=u.createExecContext(t,I,d);s=u.executeFunction(v,i)}else t&&(s=t[n],a?(s=`${(0,o.m)(s)}${c}${(0,o.m)(t[a])}`,r&&(s=`${s}${c}${(0,o.m)(t[r])}`)):"string"==typeof s&&i&&(y?s=s?new Date(s).getTime():null:p&&(s=s?m(s):null)));if(x&&"number"==typeof s&&isFinite(s)){const e=t&&parseFloat(t[F]);s=(0,o.B)(s,x,e,_)}w.push(s)})),w}}}]);
//# sourceMappingURL=2611.16f570fb.js.map